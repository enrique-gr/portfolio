<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebTunnel CFD - Browser Navier-Stokes Solver</title>
  <style>
    body {
      margin: 0;
      background-color: #111;
      color: #ccc;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding-top: 20px;
      box-sizing: border-box;
    }

    h2 {
      margin: 5px 0 10px;
      color: #fff;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    canvas {
      border: 1px solid #444;
      background-color: #000;
      box-shadow: 0 0 30px rgba(0,0,0,0.7);
      cursor: crosshair;
      max-width: 100%;
      height: auto;
    }

    #controls {
      margin-top: 15px;
      padding: 10px 14px;
      background: #222;
      border-radius: 8px;
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      font-size: 13px;
    }

    input[type="file"] {
      color: #aaa;
      font-size: 12px;
    }

    button {
      background: #007bff;
      border: none;
      padding: 5px 15px;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    button:hover {
      background: #0056b3;
    }

    .label {
      font-size: 12px;
      color: #888;
      margin-right: 5px;
    }
  </style>
</head>
<body>

  <h2>WebTunnel CFD</h2>
  <canvas id="simCanvas"></canvas>

  <div id="controls">
    <div>
      <span class="label">Upload Shape:</span>
      <input type="file" id="imageLoader" accept="image/*">
    </div>
    <button onclick="resetSim()">Clear / Reset Flow</button>
    <div>
      <label><input type="checkbox" id="toggleWind" checked> Wind Tunnel On</label>
    </div>
  </div>

<script>
/**
 * WIND TUNNEL FLUID SOLVER WITH IMAGE IMPORT
 */

// --- CONFIGURATION ---
const N = 128;            // Grid Resolution
const SCALE = 4;          // Display Scale
const ITER = 10;          // Solver Iterations
const DIFFUSION = 0.0000;
const VISCOSITY = 0.0000;
const DT = 0.1;

// --- GLOBALS ---
const size = (N + 2) * (N + 2);

// Fluid Arrays
let u = new Float32Array(size);
let v = new Float32Array(size);
let u_prev = new Float32Array(size);
let v_prev = new Float32Array(size);
let dens = new Float32Array(size);
let dens_prev = new Float32Array(size);

// Obstacle Array
let obstacle = new Uint8Array(size);

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
canvas.width = N * SCALE;
canvas.height = N * SCALE;

// --- INITIALIZATION ---
function init() {
  const cx = N / 2;
  const cy = N / 2;
  const r = N / 8;
  for (let j = 0; j < N + 2; j++) {
    for (let i = 0; i < N + 2; i++) {
      let dx = i - cx;
      let dy = j - cy;
      obstacle[IX(i, j)] = Math.sqrt(dx*dx + dy*dy) < r ? 1 : 0;
    }
  }
}

function resetSim() {
  u.fill(0);
  v.fill(0);
  u_prev.fill(0);
  v_prev.fill(0);
  dens.fill(0);
  dens_prev.fill(0);
}

// --- IMAGE IMPORT ---
document.getElementById('imageLoader').addEventListener('change', handleImage, false);

function handleImage(e) {
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      const tempC = document.createElement('canvas');
      tempC.width = N;
      tempC.height = N;
      const tCtx = tempC.getContext('2d');

      tCtx.fillStyle = "white";
      tCtx.fillRect(0,0,N,N);
      tCtx.drawImage(img, 0, 0, N, N);

      const imgData = tCtx.getImageData(0, 0, N, N).data;
      obstacle.fill(0);

      for (let j = 0; j < N; j++) {
        for (let i = 0; i < N; i++) {
          const p = (j * N + i) * 4;
          const brightness = (imgData[p] + imgData[p+1] + imgData[p+2]) / 3;
          if (brightness < 150) obstacle[IX(i+1, j+1)] = 1;
        }
      }
      resetSim();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(e.target.files[0]);
}

// --- SOLVER CORE ---
function IX(x, y) {
  if (x < 0) x = 0;
  if (x > N + 1) x = N + 1;
  if (y < 0) y = 0;
  if (y > N + 1) y = N + 1;
  return x + (N + 2) * y;
}

function enforce_obstacles(u, v) {
  for (let i = 0; i < size; i++) {
    if (obstacle[i]) {
      u[i] = 0;
      v[i] = 0;
      dens[i] = 0;
    }
  }
}

function lin_solve(b, x, x0, a, c) {
  let cRecip = 1.0 / c;
  for (let k = 0; k < ITER; k++) {
    for (let j = 1; j <= N; j++) {
      for (let i = 1; i <= N; i++) {
        if (obstacle[IX(i,j)]) continue;
        x[IX(i, j)] =
          (x0[IX(i, j)] +
            a * (x[IX(i-1,j)] + x[IX(i+1,j)] +
                 x[IX(i,j-1)] + x[IX(i,j+1)])) *
          cRecip;
      }
    }
    set_bnd(b, x);
  }
}

function set_bnd(b, x) {
  for (let i = 1; i <= N; i++) {
    x[IX(0,i)] = b===1 ? -x[IX(1,i)] : x[IX(1,i)];
    x[IX(N+1,i)] = b===1 ? -x[IX(N,i)] : x[IX(N,i)];
    x[IX(i,0)] = b===2 ? -x[IX(i,1)] : x[IX(i,1)];
    x[IX(i,N+1)] = b===2 ? -x[IX(i,N)] : x[IX(i,N)];
  }
}

function diffuse(b, x, x0, diff, dt) {
  let a = dt * diff * (N - 2) * (N - 2);
  lin_solve(b, x, x0, a, 1 + 4 * a);
}

function advect(b, d, d0, u, v, dt) {
  let dt0 = dt * (N - 2);
  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      if (obstacle[IX(i,j)]) continue;

      let x = i - dt0 * u[IX(i,j)];
      let y = j - dt0 * v[IX(i,j)];

      if (x < .5) x = .5;
      if (x > N+.5) x = N+.5;
      if (y < .5) y = .5;
      if (y > N+.5) y = N+.5;

      let i0 = Math.floor(x);
      let j0 = Math.floor(y);
      let i1 = i0 + 1;
      let j1 = j0 + 1;

      let s1 = x - i0, s0 = 1 - s1;
      let t1 = y - j0, t0 = 1 - t1;

      d[IX(i,j)] =
        s0 * (t0*d0[IX(i0,j0)] + t1*d0[IX(i0,j1)]) +
        s1 * (t0*d0[IX(i1,j0)] + t1*d0[IX(i1,j1)]);
    }
  }
  set_bnd(b, d);
}

function project(u, v, p, div) {
  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      if (obstacle[IX(i,j)]) {
        p[IX(i,j)] = div[IX(i,j)] = 0;
        continue;
      }

      div[IX(i,j)] =
        -0.5 * (u[IX(i+1,j)] - u[IX(i-1,j)] +
                v[IX(i,j+1)] - v[IX(i,j-1)]) / N;
      p[IX(i,j)] = 0;
    }
  }

  set_bnd(0, div);
  set_bnd(0, p);
  lin_solve(0, p, div, 1, 4);

  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      if (obstacle[IX(i,j)]) continue;
      u[IX(i,j)] -= 0.5 * N * (p[IX(i+1,j)] - p[IX(i-1,j)]);
      v[IX(i,j)] -= 0.5 * N * (p[IX(i,j+1)] - p[IX(i,j-1)]);
    }
  }
}

// MAIN STEP LOOP
function step() {
  if (document.getElementById('toggleWind').checked) {
    for (let j = 1; j <= N; j++) {
      u[IX(1, j)] = 5.0;
      dens[IX(1, j)] = j % 8 === 4 ? 255 : 0;
    }
  }

  diffuse(1, u_prev, u, VISCOSITY, DT);
  diffuse(2, v_prev, v, VISCOSITY, DT);

  project(u_prev, v_prev, u, v);

  advect(1, u, u_prev, u_prev, v_prev, DT);
  advect(2, v, v_prev, u_prev, v_prev, DT);

  project(u, v, u_prev, v_prev);

  diffuse(0, dens_prev, dens, DIFFUSION, DT);
  advect(0, dens, dens_prev, u, v, DT);

  enforce_obstacles(u, v);
}

// RENDER
function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      let x = i * SCALE;
      let y = j * SCALE;

      if (obstacle[IX(i+1,j+1)]) {
        ctx.fillStyle = "#555";
        ctx.fillRect(x,y,SCALE,SCALE);
      } else {
        let d = dens[IX(i+1,j+1)];
        if (d > 1) {
          ctx.fillStyle = `rgba(0,255,255,${Math.min(1, d/255)})`;
          ctx.fillRect(x,y,SCALE,SCALE);
        }
      }
    }
  }
}

// INTERACTION
let isMouseDown = false;

canvas.addEventListener("mousedown", () => isMouseDown = true);
window.addEventListener("mouseup", () => isMouseDown = false);

canvas.addEventListener("mousemove", e => {
  if (!isMouseDown) return;
  let gridX = Math.floor(e.offsetX / SCALE);
  let gridY = Math.floor(e.offsetY / SCALE);
  if (gridX < 1 || gridX > N || gridY < 1 || gridY > N) return;
  dens[IX(gridX, gridY)] += 100;
  u[IX(gridX, gridY)] += 10;
});

// LOOP
init();

function loop() {
  step();
  render();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
